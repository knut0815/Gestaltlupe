<?xml version="1.0" encoding="utf-8"?>
<ParameterDict>
  <Entry Key="Formula.Parameters.anglex" Value="0" />
  <Entry Key="Formula.Parameters.angley" Value="0" />
  <Entry Key="Formula.Parameters.anglez" Value="33" />
  <Entry Key="Formula.Parameters.bailout" Value="17" />
  <Entry Key="Formula.Parameters.box" Value="0" />
  <Entry Key="Formula.Parameters.scale" Value="1.2" />
  <Entry Key="Formula.Parameters.size" Value="0" />
  <Entry Key="Formula.Parameters.xd" Value="4" />
  <Entry Key="Formula.Parameters.yd" Value="4" />
  <Entry Key="Formula.Parameters.zd" Value="0.8" />
  <Entry Key="Formula.Static.Cycles" Value="20" />
  <Entry Key="Formula.Static.Julia" Value="1" />
  <Entry Key="Formula.Static.jx" Value="0" />
  <Entry Key="Formula.Static.jy" Value="0" />
  <Entry Key="Formula.Static.jz" Value="0" />
  <Entry Key="Formula.Static.MinCycle" Value="0" />
  <Entry Key="Intern.Formula.Source" Value="double x=0;&#xA;double y=0;&#xA;double z=0;&#xA;double sx=0;&#xA;double sy=0;&#xA;double sz=0;&#xA;double _xd=1;&#xA;double _yd=1;&#xA;double _zd=0;&#xA;double _anglex=0;&#xA;double _angley=0;&#xA;double _anglez=0;&#xA;double _scale=1.5;&#xA;double _size=0.1;&#xA;double _bailout=5;&#xA;bool _box=true;&#xA;&#xA;&#xA;public override void Init()&#xA;{&#xA;  base.Init();&#xA;  _xd=GetOrSetDouble(&quot;xd&quot;,1);&#xA;  _yd=GetOrSetDouble(&quot;yd&quot;,1);&#xA;  _zd=GetOrSetDouble(&quot;zd&quot;,0);&#xA;  _anglex=Math.PI*GetOrSetDouble(&quot;anglex&quot;,0)/180.0;&#xA;  _angley=Math.PI*GetOrSetDouble(&quot;angley&quot;,0)/180.0;&#xA;  _anglez=Math.PI*GetOrSetDouble(&quot;anglez&quot;,0)/180.0;&#xA;  _size=GetOrSetDouble(&quot;size&quot;,0.1);&#xA;  _bailout=GetOrSetDouble(&quot;bailout&quot;,5);&#xA;  _scale=GetOrSetDouble(&quot;scale&quot;,1.5);&#xA;  if(!Fractrace.Basic.ParameterDict.Current.Exists(&quot;Formula.Parameters.box&quot;))&#xA;  {&#xA;    Fractrace.Basic.ParameterDict.Current[&quot;Formula.Parameters.box&quot;]=&quot;1&quot;;&#xA;  }&#xA;  _box=Fractrace.Basic.ParameterDict.Current.GetBool (&quot;Formula.Parameters.box&quot;);&#xA;  Fractrace.Basic.ParameterDict.Current[&quot;Formula.Parameters.box.PARAMETERINFO.Datatype&quot;]=&quot;Bool&quot;;&#xA;}&#xA;&#xA;&#xA;public override bool GetBool(double x,double y,double z)&#xA;{&#xA;  this.x=x;&#xA;  this.y=y;&#xA;  this.z=z;&#xA;  this.sx=x;&#xA;  this.sy=y;&#xA;  this.sz=z;&#xA;  return GetBool(_cycles);&#xA;}&#xA;&#xA;&#xA;public bool GetBool(int cycles)&#xA;{&#xA;  x+=_jx;&#xA;  y+=_jy;&#xA;  z+=_jz;&#xA;  &#xA;/*&#xA;  {&#xA;    double xx=sx*sx;&#xA;    double yy=sy*sy;&#xA;    double zz=sz*sz;&#xA;    double rs=xx+yy+zz;&#xA;    {&#xA;      additionalPointInfo.red+=xx / rs;&#xA;      additionalPointInfo.green+=yy / rs;&#xA;      additionalPointInfo.blue+=zz / rs;&#xA;    }&#xA;  }&#xA;*/&#xA;  &#xA;  if(cycles&lt;=0)&#xA;  {&#xA;    additionalPointInfo.red=0.5;&#xA;    additionalPointInfo.green=0.5;&#xA;    additionalPointInfo.blue=0.5;&#xA;    return true;&#xA;  }&#xA;  double r=x*x+y*y+z*z;&#xA;  if(r&lt;_size)&#xA;  {&#xA;    additionalPointInfo.red=0;&#xA;    additionalPointInfo.green=0;&#xA;    additionalPointInfo.blue=0.5;&#xA;    return true;&#xA;  }&#xA;  if(r&gt;_bailout)return false;&#xA;  if (cycles&gt;3)&#xA;  Scale(_scale);&#xA;  if(_anglex!=0)RotateX(_anglex);&#xA;  if(_angley!=0)RotateY(_angley);&#xA;  if(_anglez!=0)RotateZ(_anglez);&#xA;  double x1=x;&#xA;  double y1=y;&#xA;  double z1=z;&#xA;  {&#xA;    if(_xd!=0)&#xA;    {&#xA;      x=x1;&#xA;      y=y1;&#xA;      z=z1;&#xA;      Move(_xd,0,0);&#xA;      if(GetBool(cycles-1))&#xA;      {&#xA;if(additionalPointInfo.red!=0.5)&#xA;{&#xA;        additionalPointInfo.red=1;&#xA;        additionalPointInfo.green=0;&#xA;        additionalPointInfo.blue=0.5;&#xA;}&#xA;        return true;&#xA;&#xA;      }&#xA;      x=x1;&#xA;      y=y1;&#xA;      z=z1;&#xA;      Move(-_xd,0,0);&#xA;      if(GetBool(cycles-1))&#xA;      {&#xA;if(additionalPointInfo.red!=0.5)&#xA;{&#xA;        additionalPointInfo.red=1;&#xA;        additionalPointInfo.green=0;&#xA;        additionalPointInfo.blue=0.5;&#xA;}&#xA;        return true;&#xA;      }&#xA;    }&#xA;    if(_yd!=0)&#xA;    {&#xA;      x=x1;&#xA;      y=y1;&#xA;      z=z1;&#xA;      Move(0,_yd,0);&#xA;      if(GetBool(cycles-1))&#xA;      {&#xA;if(additionalPointInfo.red!=0.5)&#xA;{&#xA;&#xA;        additionalPointInfo.red=1;&#xA;        additionalPointInfo.green=0;&#xA;        additionalPointInfo.blue=0.5;&#xA;}&#xA;        return true;&#xA;      }&#xA;      x=x1;&#xA;      y=y1;&#xA;      z=z1;&#xA;      Move(0,-_yd,0);&#xA;      if(GetBool(cycles-1))&#xA;      {&#xA; if(additionalPointInfo.red!=0.5)&#xA;{&#xA;       additionalPointInfo.red=0;&#xA;        additionalPointInfo.green=1;&#xA;        additionalPointInfo.blue=0.5;&#xA;}&#xA;        return true;&#xA;      }&#xA;    }&#xA;    if(_zd!=0)&#xA;    {&#xA;      x=x1;&#xA;      y=y1;&#xA;      z=z1;&#xA;      Move(0,0,_zd);&#xA;      if(GetBool(cycles-1))&#xA;      {&#xA;        additionalPointInfo.red=0.5;&#xA;        additionalPointInfo.green=0.5;&#xA;        additionalPointInfo.blue=1;&#xA;        return true;&#xA;      }&#xA;      x=x1;&#xA;      y=y1;&#xA;      z=z1;&#xA;      Move(0,0,-_zd);&#xA;      if(GetBool(cycles-1))&#xA;      {&#xA;        additionalPointInfo.red=0.5;&#xA;        additionalPointInfo.green=0.5;&#xA;        additionalPointInfo.blue=0;&#xA;        return true;&#xA;      }&#xA;    }&#xA;  }&#xA;  x=x1;&#xA;  y=y1;&#xA;  z=z1;&#xA;  return false;&#xA;}&#xA;bool Bailout()&#xA;{&#xA;  if(_box)return !InBox();&#xA;  return !InSphere();&#xA;}&#xA;bool InBox()&#xA;{&#xA;  if(x*x&gt;_size)return false;&#xA;  if(y*y&gt;_size)return false;&#xA;  if(z*z&gt;_size)return false;&#xA;  return true;&#xA;}&#xA;bool InSphere()&#xA;{&#xA;  if(x*x+y*y+z*z&gt;_size)return false;&#xA;  return true;&#xA;}&#xA;void Move(double xd,double yd,double zd)&#xA;{&#xA;  x+=xd;&#xA;  y+=yd;&#xA;  z+=zd;&#xA;}&#xA;void Scale(double scale)&#xA;{&#xA;  x*=scale;&#xA;  y*=scale;&#xA;  z*=scale;&#xA;}&#xA;void RotateX(double angle)&#xA;{&#xA;  double re=Math.Cos(angle );&#xA;  double im=Math.Sin(angle );&#xA;  double a=re * y-im * z;&#xA;  z=re * z+im * y;&#xA;  y=a;&#xA;}&#xA;void RotateY(double angle)&#xA;{&#xA;  double re=Math.Cos(angle );&#xA;  double im=Math.Sin(angle );&#xA;  double a=re * x-im * z;&#xA;  z=re * z+im * x;&#xA;  x=a;&#xA;}&#xA;void RotateZ(double angle)&#xA;{&#xA;  double re=Math.Cos(angle );&#xA;  double im=Math.Sin(angle );&#xA;  double a=re * x-im * y;&#xA;  y=re * y+im * x;&#xA;  x=a;&#xA;}&#xA;" />
  <Entry Key="Intern.Version" Value="7" />
  <Entry Key="Renderer.ColorFactor.Blue" Value="1" />
  <Entry Key="Renderer.ColorFactor.Green" Value="1" />
  <Entry Key="Renderer.ColorFactor.Red" Value="1" />
  <Entry Key="Renderer.ColorFactor.RgbType" Value="1" />
  <Entry Key="Renderer.ColorGreyness" Value="0" />
  <Entry Key="Renderer.ColorInside" Value="0" />
  <Entry Key="Renderer.ColorIntensity" Value="1" />
  <Entry Key="Renderer.ColorOutside" Value="1" />
  <Entry Key="Scene.CenterX" Value="-2.08122605545742" />
  <Entry Key="Scene.CenterY" Value="1.07120900257608" />
  <Entry Key="Scene.CenterZ" Value="-4.89870240710624" />
  <Entry Key="Scene.Radius" Value="3.14930671298582" />
  <Entry Key="Transformation.Camera.AngleX" Value="103.489237342551" />
  <Entry Key="Transformation.Camera.AngleY" Value="-1.09995972410099" />
  <Entry Key="Transformation.Camera.AngleZ" Value="138.58820988556" />
  <Entry Key="Transformation.Camera.IsometricProjection" Value="0" />
  <Entry Key="Transformation.Camera.Position" Value="1" />
</ParameterDict>