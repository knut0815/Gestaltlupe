<?xml version="1.0" encoding="utf-8"?>
<ParameterDict>
  <Entry Key="Formula.Parameters.BulbVariant" Value="0" />
  <Entry Key="Formula.Parameters.Power" Value="2" />
  <Entry Key="Formula.Parameters.SinusVariant" Value="1" />
  <Entry Key="Formula.Static.Cycles" Value="75" />
  <Entry Key="Formula.Static.Formula" Value="-1" />
  <Entry Key="Formula.Static.jx" Value="0" />
  <Entry Key="Formula.Static.jy" Value="0" />
  <Entry Key="Formula.Static.jz" Value="0" />
  <Entry Key="Formula.Static.jzz" Value="0" />
  <Entry Key="Formula.Static.MinCycle" Value="51" />
  <Entry Key="Intern.Formula.Source" Value="int gr=20;&#xA;double _power=2;&#xA;bool _sinusVariant=false;&#xA;bool _bulbVariant=false;&#xA;&#xA;public override void Init() &#xA;{&#xA;  base.Init();&#xA;  _power=GetOrSetDouble(&quot;Power&quot;,2,&quot;Mandelbulb Power.&quot;);&#xA;  if(!Fractrace.Basic.ParameterDict.Current.Exists(&quot;Formula.Parameters.SinusVariant&quot;))&#xA;  {&#xA;    Fractrace.Basic.ParameterDict.Current[&quot;Formula.Parameters.SinusVariant&quot;] = &quot;0&quot;;&#xA;  }&#xA;  _sinusVariant=Fractrace.Basic.ParameterDict.Current.GetBool  (&quot;Formula.Parameters.SinusVariant&quot;);&#xA;  if(!Fractrace.Basic.ParameterDict.Current.Exists(&quot;Formula.Parameters.BulbVariant&quot;))&#xA;  {&#xA;    Fractrace.Basic.ParameterDict.Current[&quot;Formula.Parameters.BulbVariant&quot;] = &quot;0&quot;;&#xA;  }&#xA;  _bulbVariant=Fractrace.Basic.ParameterDict.Current.GetBool  (&quot;Formula.Parameters.BulbVariant&quot;);&#xA;  Fractrace.Basic.ParameterDict.Current[&quot;Formula.Parameters.SinusVariant.PARAMETERINFO.Datatype&quot;] = &quot;Bool&quot;;&#xA;  Fractrace.Basic.ParameterDict.Current[&quot;Formula.Parameters.BulbVariant.PARAMETERINFO.Datatype&quot;] = &quot;Bool&quot;;&#xA;}&#xA;&#xA;public override bool GetBool(double x, double y, double z)&#xA;{&#xA;&#xA;double br, bi, bj;&#xA;if (_isJulia)&#xA;{&#xA;  br = _jx; bi = _jy; bj = _jz;&#xA;}&#xA;else&#xA;{&#xA;  br = x; bi = y; bj = z;&#xA;  x = _jx; y = _jy; z = _jz;&#xA;}&#xA;&#xA;//if(bi&gt;0) return 1;&#xA;          &#xA;double xx = x * x; &#xA;double yy = y * y; &#xA;double zz = z * z;&#xA;double r = 0;&#xA;double re=0,im=0,a=0;  &#xA;double theta =0;&#xA;    &#xA;for (int n = 1; n &lt; _cycles; n++) &#xA;{&#xA;  double phi = Math.Atan2(y, x);&#xA;&#xA;// rotation 1:&#xA;  x = Math.Cos(-phi) * x - Math.Sin(-phi) * y;&#xA;  y=0;&#xA;&#xA;// rotation 2&#xA;if(_sinusVariant)&#xA;  theta = (_power-1)*Math.Atan2(z, x);&#xA;else&#xA;  theta = (_power-1)*Math.Atan2(-z, -x);&#xA; &#xA; if(_bulbVariant &amp;&amp; n==2 )&#xA;    theta =Math.PI-theta;&#xA;  re = Math.Cos(theta );&#xA;  im = Math.Sin(theta );&#xA;  a = re * x - im * z;&#xA;  z = re * z + im * x;&#xA;  x = a;&#xA;&#xA;// rotation 3&#xA;  re = Math.Cos(_power*phi);&#xA;  im = Math.Sin(_power*phi);&#xA;  a = re * x - im * y;&#xA;  y = re * y + im * x;&#xA;  x = a;&#xA;&#xA;  xx = x * x; yy = y * y; zz = z * z;&#xA;  r = xx + yy +zz;          &#xA;  r = Math.Pow(r,(_power-1)/2);     &#xA;  x *= r;     &#xA;  y *= r;     &#xA;  z *= r;    &#xA;  y += bj;    &#xA;  x += br;    &#xA;  z += bi;&#xA;            &#xA;  if (r &gt; gr) &#xA;    return false;            &#xA;            &#xA;  if (n &gt; _cycles/ 3 &amp;&amp; n &lt; _cycles/ 1.2)              &#xA;  {&#xA;    additionalPointInfo.red += xx / r;&#xA;    additionalPointInfo.green += yy / r;&#xA;    additionalPointInfo.blue += zz / r;             &#xA;  }          &#xA;}&#xA;&#xA;          &#xA;return (true);&#xA;}&#xA;" />
  <Entry Key="Intern.Version" Value="4" />
  <Entry Key="Renderer.ColorFactor.Blue" Value="0.4" />
  <Entry Key="Renderer.ColorFactor.Green" Value="1.2" />
  <Entry Key="Renderer.ColorFactor.Red" Value="1" />
  <Entry Key="Renderer.ColorFactor.RgbType" Value="1" />
  <Entry Key="Renderer.ColorGreyness" Value="0.5" />
  <Entry Key="Renderer.ColorInside" Value="0" />
  <Entry Key="Renderer.ColorIntensity" Value="1" />
  <Entry Key="Renderer.ColorOutside" Value="1" />
  <Entry Key="Scene.CenterX" Value="0.734892996732016" />
  <Entry Key="Scene.CenterY" Value="0.786104813147489" />
  <Entry Key="Scene.CenterZ" Value="0.340557493640114" />
  <Entry Key="Scene.Radius" Value="1.24278625962591" />
  <Entry Key="Transformation.Camera.AngleX" Value="-117.61679153311" />
  <Entry Key="Transformation.Camera.AngleY" Value="-28.8748382343596" />
  <Entry Key="Transformation.Camera.AngleZ" Value="-121.426984818833" />
  <Entry Key="Transformation.Perspective.Cameraposition" Value="1" />
  <Entry Key="View.Perspective" Value="1" />
</ParameterDict>