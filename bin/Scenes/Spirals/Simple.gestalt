<?xml version="1.0" encoding="utf-8"?>
<ParameterDict>
  <Entry Key="Formula.Parameters.anglex" Value="26" />
  <Entry Key="Formula.Parameters.angley" Value="0" />
  <Entry Key="Formula.Parameters.anglez" Value="0" />
  <Entry Key="Formula.Parameters.bailout" Value="6" />
  <Entry Key="Formula.Parameters.box" Value="0" />
  <Entry Key="Formula.Parameters.scale" Value="1.1" />
  <Entry Key="Formula.Parameters.size" Value="0.4" />
  <Entry Key="Formula.Parameters.yd" Value="1" />
  <Entry Key="Formula.Static.Cycles" Value="44" />
  <Entry Key="Formula.Static.Julia" Value="1" />
  <Entry Key="Formula.Static.jx" Value="0" />
  <Entry Key="Formula.Static.jy" Value="0" />
  <Entry Key="Formula.Static.jz" Value="0" />
  <Entry Key="Formula.Static.MinCycle" Value="0" />
  <Entry Key="Intern.Formula.Source" Value="double x=0;&#xA;double y=0;&#xA;double z=0;&#xA;double _yd=1;&#xA;double _anglex=0;&#xA;double _angley=0;&#xA;double _anglez=0;&#xA;double _scale=1.5;&#xA;double _size=0.1;&#xA;double _bailout=5;&#xA;bool _box=true;&#xA;&#xA;&#xA;public override void Init()&#xA;{&#xA;  base.Init();&#xA;  if(GetString(&quot;intern.Formula.TempUpdateVal&quot;)!=&quot;c474d2f4c5974c6863055df0ecdc78bf&quot;)&#xA;  {&#xA;    SetParameterBulk(&quot;Formula.Parameters: anglex=22.5 angley=0 anglez=0 bailout=12 box=1 scale=1.25 size=0.5 yd=1 Formula.Static: Cycles=55 Julia=1 jx=0 jy=0 jz=0 Scene: CenterX=-1.31205445279311 CenterY=-0.821247287171884 CenterZ=-0.563560273849805 Radius=3.77691171653579 Transformation.Camera: AngleX=-0.409855217034559 AngleY=-23.3916795219528 AngleZ=112.925482270802 IsometricProjection=0 Position=1 intern.Formula: TempUpdateVal=c474d2f4c5974c6863055df0ecdc78bf&quot;);&#xA;  }&#xA;  _yd=GetOrSetDouble(&quot;yd&quot;,1);&#xA;  _anglex=Math.PI*GetOrSetDouble(&quot;anglex&quot;,0)/180.0;&#xA;  _angley=Math.PI*GetOrSetDouble(&quot;angley&quot;,0)/180.0;&#xA;  _anglez=Math.PI*GetOrSetDouble(&quot;anglez&quot;,0)/180.0;&#xA;  _size=GetOrSetDouble(&quot;size&quot;,0.1);&#xA;  _bailout=GetOrSetDouble(&quot;bailout&quot;,5);&#xA;  _scale=GetOrSetDouble(&quot;scale&quot;,1.5);&#xA;  _box=GetOrSetBool(&quot;box&quot;,false);&#xA;}&#xA;&#xA;&#xA;public override bool GetBool(double x,double y,double z)&#xA;{&#xA;  this.x=x;&#xA;  this.y=y;&#xA;  this.z=z;&#xA;  return GetBool(_cycles);&#xA;}&#xA;&#xA;&#xA;public bool GetBool(int cycles)&#xA;{&#xA;  if(cycles&lt;=0)return true;&#xA;  x+=_jx;&#xA;  y+=_jy;&#xA;  z+=_jz;&#xA;  double r=x*x+y*y+z*z;&#xA;  if(r&gt;_bailout)return false;&#xA;  if(InSet())&#xA;  {&#xA;    additionalPointInfo.red=0.5;&#xA;    additionalPointInfo.green=0.5;&#xA;    additionalPointInfo.blue=3+0.3*(cycles-_cycles);&#xA;    if(additionalPointInfo.blue&lt;0)additionalPointInfo.blue=0;&#xA;    if(cycles&lt;40)&#xA;    {&#xA;      additionalPointInfo.red=40/cycles;&#xA;      additionalPointInfo.green=1-40/cycles;&#xA;      additionalPointInfo.blue=0;&#xA;    }&#xA;    return true;&#xA;  }&#xA;  Scale(_scale);&#xA;  if(_anglex!=0)RotateX(_anglex);&#xA;  if(_angley!=0)RotateY(_angley);&#xA;  if(_anglez!=0)RotateZ(_anglez);&#xA;  double x1=x;&#xA;  double y1=y;&#xA;  double z1=z;&#xA;  y+=_yd;&#xA;  if(GetBool(cycles-1))return true;&#xA;  x=x1;&#xA;  y=y1;&#xA;  z=z1;&#xA;  y-=_yd;&#xA;  if(GetBool(cycles-1))return true;&#xA;  x=x1;&#xA;  y=y1;&#xA;  z=z1;&#xA;  return false;&#xA;}&#xA;bool InSet()&#xA;{&#xA;  if(_box)return InBox();&#xA;  return InSphere();&#xA;}&#xA;bool InBox()&#xA;{&#xA;  if(x*x&gt;_size)return false;&#xA;  if(y*y&gt;_size)return false;&#xA;  if(z*z&gt;_size)return false;&#xA;  return true;&#xA;}&#xA;bool InSphere()&#xA;{&#xA;  if(x*x+y*y+z*z&gt;_size)return false;&#xA;  return true;&#xA;}&#xA;void Scale(double scale)&#xA;{&#xA;  x*=scale;&#xA;  y*=scale;&#xA;  z*=scale;&#xA;}&#xA;void RotateX(double angle)&#xA;{&#xA;  double re=Math.Cos(angle );&#xA;  double im=Math.Sin(angle );&#xA;  double a=re * y-im * z;&#xA;  z=re * z+im * y;&#xA;  y=a;&#xA;}&#xA;void RotateY(double angle)&#xA;{&#xA;  double re=Math.Cos(angle );&#xA;  double im=Math.Sin(angle );&#xA;  double a=re * x-im * z;&#xA;  z=re * z+im * x;&#xA;  x=a;&#xA;}&#xA;void RotateZ(double angle)&#xA;{&#xA;  double re=Math.Cos(angle );&#xA;  double im=Math.Sin(angle );&#xA;  double a=re * x-im * y;&#xA;  y=re * y+im * x;&#xA;  x=a;&#xA;}&#xA;" />
  <Entry Key="Intern.Version" Value="7" />
  <Entry Key="Renderer.ColorFactor.Blue" Value="1" />
  <Entry Key="Renderer.ColorFactor.Green" Value="1" />
  <Entry Key="Renderer.ColorFactor.Red" Value="1" />
  <Entry Key="Renderer.ColorFactor.RgbType" Value="1" />
  <Entry Key="Renderer.ColorGreyness" Value="0" />
  <Entry Key="Renderer.ColorInside" Value="0" />
  <Entry Key="Renderer.ColorIntensity" Value="1" />
  <Entry Key="Renderer.ColorOutside" Value="0" />
  <Entry Key="Scene.CenterX" Value="-0.0314148976480281" />
  <Entry Key="Scene.CenterY" Value="-1.55798844007809" />
  <Entry Key="Scene.CenterZ" Value="-1.22658256535662" />
  <Entry Key="Scene.Radius" Value="0.878388952755752" />
  <Entry Key="Transformation.Camera.AngleX" Value="-0.409855217034559" />
  <Entry Key="Transformation.Camera.AngleY" Value="-23.3916795219528" />
  <Entry Key="Transformation.Camera.AngleZ" Value="112.925482270802" />
  <Entry Key="Transformation.Camera.IsometricProjection" Value="0" />
  <Entry Key="Transformation.Camera.Position" Value="1" />
</ParameterDict>